1. 로딩 화면에서 Login 검사

2. 채팅방 날짜 표시

2022.09.20

1. 확인하지 않은 채팅 수 표시 O

2. DetailItem화면에서 채팅하기 버튼 누르면 바로 채팅방 생기는데 메시지 보내면 채팅방 생기도록 변경하기 O

2022.09.21

1. 채팅 알림 O
    - 버그: 채팅 읽고 나오면 알림 또 옴 -> 채팅방을 나오면
    chatRooms.child(myUid).child(userUid).child("visited").setValue(|true or false|); 로 값이 바뀌게 되고
    ChatRepository -> getMyChatRooms() 메서드의  addChildEventListener() 변경을 감지함.
    visited 값이 false이면 lastMessage를 알림으로 보내도록 했으므로 변경이 일어남과 동시에 알림을 다시 보냄

2022.09.22

1. 채팅 알림 버그 해결 O
    - 버그 내용: 채팅 읽고 채팅방 나오면 알림 중복 발생
        해결
        1. LastMessage class에 checked 필드 추가
        2. ChatRepository getMyChatRooms() 메서드에서 내 채팅방에 변경이 일어날때 알림을 보내는데 이때 조건으로 내가 채팅방에 들어가 있지 않을때 && lastMessage class의 checked가 false일때만 채팅 알림 발생 시킴



chatAdapter
public class MyAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> {

    private ArrayList<MyData> myDataList;

    // ViewHolder 클래스들
    private static class ViewHolder1 extends RecyclerView.ViewHolder {
        private TextView textView1;
        public ViewHolder1(View itemView) {
            super(itemView);
            textView1 = itemView.findViewById(R.id.text1);
        }
    }

    private static class ViewHolder2 extends RecyclerView.ViewHolder {
        private TextView textView1;
        private Button button1;
        public ViewHolder2(View itemView) {
            super(itemView);
            textView1 = itemView.findViewById(R.id.text1);
            button1 = itemView.findViewById(R.id.button1);
        }
    }

    // 생성자
    public MyAdapter(ArrayList<MyData> myDataList) {
        this.myDataList = myDataList;
    }

    // ViewHolder 생성
    @Override
    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        switch (viewType) {
            case 0:
                View view1 = LayoutInflater.from(parent.getContext()).inflate(R.layout.viewholder1, parent, false);
                return new ViewHolder1(view1);
            case 1:
                View view2 = LayoutInflater.from(parent.getContext()).inflate(R.layout.viewholder2, parent, false);
                return new ViewHolder2(view2);
        }
        return null;
    }

    // ViewHolder와 데이터를 연결
    @Override
    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
        switch (holder.getItemViewType()) {
            case 0:
                ((ViewHolder1) holder).textView1.setText(myDataList.get(position).getText1());
                break;
            case 1:
                ((ViewHolder2) holder).textView1.setText(myDataList.get(position).getText1());
                ((ViewHolder2) holder).button1.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        // 버튼 클릭 시 실행될 코드
                    }
                });
                break;
        }
    }

    // 데이터 개수 반환
    @Override
    public int getItemCount() {
        return myDataList.size();
    }

    // 아이템 뷰 타입 반환
    @Override
    public int getItemViewType(int position) {
        if (myDataList.get(position).getType() == 1) {
            return 1;
        } else {
            return 0;
        }
    }
}



public class MyAdapter extends RecyclerView.Adapter<MyAdapter.MyViewHolder> {

    private List<MyData> mDataList;

    @Override
    public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext()).inflate(viewType, parent, false);
        MyViewHolder viewHolder = new MyViewHolder(view);
        return viewHolder;
    }

    @Override
    public void onBindViewHolder(MyViewHolder holder, int position) {
        MyData data = mDataList.get(position);

        // 뷰홀더를 재활용할 수 있는지 확인합니다.
        if (holder.itemViewType == R.layout.item_type1) {
            // 이전에 사용한 뷰홀더를 가져옵니다.
            TextView textView = holder.itemView.findViewById(R.id.text_view);
            // 데이터를 업데이트합니다.
            textView.setText(data.getText());
        } else {
            // 이전에 사용한 뷰홀더를 가져옵니다.
            TextView textView = holder.itemView.findViewById(R.id.text_view);
            Button button = holder.itemView.findViewById(R.id.button);
            // 데이터를 업데이트합니다.
            textView.setText(data.getText());
            button.setOnClickListener(data.getClickListener());
        }
    }

    @Override
    public int getItemCount() {
        return mDataList.size();
    }

    @Override
    public int getItemViewType(int position) {
        MyData data = mDataList.get(position);
        // 데이터에 따라 뷰 타입을 결정합니다.
        if (data.getType() == ItemType.TYPE1) {
            return R.layout.item_type1;
        } else {
            return R.layout.item_type2;
        }
    }

    public class MyViewHolder extends RecyclerView.ViewHolder {
        public MyViewHolder(View itemView) {
            super(itemView);
        }
    }
}
